{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\nvar has = require('has');\nvar isInteger = require('./isInteger');\nvar isMatchRecord = require('./isMatchRecord');\nvar predicates = {\n  // https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type\n  'Property Descriptor': function isPropertyDescriptor(Desc) {\n    var allowed = {\n      '[[Configurable]]': true,\n      '[[Enumerable]]': true,\n      '[[Get]]': true,\n      '[[Set]]': true,\n      '[[Value]]': true,\n      '[[Writable]]': true\n    };\n    if (!Desc) {\n      return false;\n    }\n    for (var key in Desc) {\n      // eslint-disable-line\n      if (has(Desc, key) && !allowed[key]) {\n        return false;\n      }\n    }\n    var isData = has(Desc, '[[Value]]');\n    var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n    if (isData && IsAccessor) {\n      throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n    }\n    return true;\n  },\n  // https://262.ecma-international.org/13.0/#sec-match-records\n  'Match Record': isMatchRecord,\n  'Iterator Record': function isIteratorRecord(value) {\n    return has(value, '[[Iterator]]') && has(value, '[[NextMethod]]') && has(value, '[[Done]]');\n  },\n  'PromiseCapability Record': function isPromiseCapabilityRecord(value) {\n    return !!value && has(value, '[[Resolve]]') && typeof value['[[Resolve]]'] === 'function' && has(value, '[[Reject]]') && typeof value['[[Reject]]'] === 'function' && has(value, '[[Promise]]') && value['[[Promise]]'] && typeof value['[[Promise]]'].then === 'function';\n  },\n  'AsyncGeneratorRequest Record': function isAsyncGeneratorRequestRecord(value) {\n    return !!value && has(value, '[[Completion]]') // TODO: confirm is a completion record\n    && has(value, '[[Capability]]') && predicates['PromiseCapability Record'](value['[[Capability]]']);\n  },\n  'RegExp Record': function isRegExpRecord(value) {\n    return value && has(value, '[[IgnoreCase]]') && typeof value['[[IgnoreCase]]'] === 'boolean' && has(value, '[[Multiline]]') && typeof value['[[Multiline]]'] === 'boolean' && has(value, '[[DotAll]]') && typeof value['[[DotAll]]'] === 'boolean' && has(value, '[[Unicode]]') && typeof value['[[Unicode]]'] === 'boolean' && has(value, '[[CapturingGroupsCount]]') && typeof value['[[CapturingGroupsCount]]'] === 'number' && isInteger(value['[[CapturingGroupsCount]]']) && value['[[CapturingGroupsCount]]'] >= 0;\n  }\n};\nmodule.exports = function assertRecord(Type, recordType, argumentName, value) {\n  var predicate = predicates[recordType];\n  if (typeof predicate !== 'function') {\n    throw new $SyntaxError('unknown record type: ' + recordType);\n  }\n  if (Type(value) !== 'Object' || !predicate(value)) {\n    throw new $TypeError(argumentName + ' must be a ' + recordType);\n  }\n};","map":{"version":3,"names":["GetIntrinsic","require","$TypeError","$SyntaxError","has","isInteger","isMatchRecord","predicates","isPropertyDescriptor","Desc","allowed","key","isData","IsAccessor","isIteratorRecord","value","isPromiseCapabilityRecord","then","isAsyncGeneratorRequestRecord","isRegExpRecord","module","exports","assertRecord","Type","recordType","argumentName","predicate"],"sources":["/Users/connor/Documents/batchtask/batchTask/node_modules/es-abstract/helpers/assertRecord.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\n\nvar has = require('has');\nvar isInteger = require('./isInteger');\n\nvar isMatchRecord = require('./isMatchRecord');\n\nvar predicates = {\n\t// https://262.ecma-international.org/6.0/#sec-property-descriptor-specification-type\n\t'Property Descriptor': function isPropertyDescriptor(Desc) {\n\t\tvar allowed = {\n\t\t\t'[[Configurable]]': true,\n\t\t\t'[[Enumerable]]': true,\n\t\t\t'[[Get]]': true,\n\t\t\t'[[Set]]': true,\n\t\t\t'[[Value]]': true,\n\t\t\t'[[Writable]]': true\n\t\t};\n\n\t\tif (!Desc) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var key in Desc) { // eslint-disable-line\n\t\t\tif (has(Desc, key) && !allowed[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar isData = has(Desc, '[[Value]]');\n\t\tvar IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n\t\tif (isData && IsAccessor) {\n\t\t\tthrow new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n\t\t}\n\t\treturn true;\n\t},\n\t// https://262.ecma-international.org/13.0/#sec-match-records\n\t'Match Record': isMatchRecord,\n\t'Iterator Record': function isIteratorRecord(value) {\n\t\treturn has(value, '[[Iterator]]') && has(value, '[[NextMethod]]') && has(value, '[[Done]]');\n\t},\n\t'PromiseCapability Record': function isPromiseCapabilityRecord(value) {\n\t\treturn !!value\n\t\t\t&& has(value, '[[Resolve]]')\n\t\t\t&& typeof value['[[Resolve]]'] === 'function'\n\t\t\t&& has(value, '[[Reject]]')\n\t\t\t&& typeof value['[[Reject]]'] === 'function'\n\t\t\t&& has(value, '[[Promise]]')\n\t\t\t&& value['[[Promise]]']\n\t\t\t&& typeof value['[[Promise]]'].then === 'function';\n\t},\n\t'AsyncGeneratorRequest Record': function isAsyncGeneratorRequestRecord(value) {\n\t\treturn !!value\n\t\t\t&& has(value, '[[Completion]]') // TODO: confirm is a completion record\n\t\t\t&& has(value, '[[Capability]]')\n\t\t\t&& predicates['PromiseCapability Record'](value['[[Capability]]']);\n\t},\n\t'RegExp Record': function isRegExpRecord(value) {\n\t\treturn value\n\t\t\t&& has(value, '[[IgnoreCase]]')\n\t\t\t&& typeof value['[[IgnoreCase]]'] === 'boolean'\n\t\t\t&& has(value, '[[Multiline]]')\n\t\t\t&& typeof value['[[Multiline]]'] === 'boolean'\n\t\t\t&& has(value, '[[DotAll]]')\n\t\t\t&& typeof value['[[DotAll]]'] === 'boolean'\n\t\t\t&& has(value, '[[Unicode]]')\n\t\t\t&& typeof value['[[Unicode]]'] === 'boolean'\n\t\t\t&& has(value, '[[CapturingGroupsCount]]')\n\t\t\t&& typeof value['[[CapturingGroupsCount]]'] === 'number'\n\t\t\t&& isInteger(value['[[CapturingGroupsCount]]'])\n\t\t\t&& value['[[CapturingGroupsCount]]'] >= 0;\n\t}\n};\n\nmodule.exports = function assertRecord(Type, recordType, argumentName, value) {\n\tvar predicate = predicates[recordType];\n\tif (typeof predicate !== 'function') {\n\t\tthrow new $SyntaxError('unknown record type: ' + recordType);\n\t}\n\tif (Type(value) !== 'Object' || !predicate(value)) {\n\t\tthrow new $TypeError(argumentName + ' must be a ' + recordType);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}